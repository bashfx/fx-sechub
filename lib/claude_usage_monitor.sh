#!/bin/bash
# claude_usage_monitor.sh - Claude CLI Usage Detection & Monitoring Tool
# Mission: MISSION_01_CLAUDE_USAGE_DETECTION
# Commander: Edgar (EDGAROS) - Vigilant Sentinel
# Purpose: Comprehensive Claude CLI usage intelligence with zero API consumption

set -euo pipefail

# Tool metadata
TOOL_NAME="Claude Usage Monitor"
TOOL_VERSION="1.0.0"
TOOL_MISSION="MISSION_01_CLAUDE_USAGE_DETECTION"

# Core directories
CLAUDE_DIR="$HOME/.claude"
PROJECTS_DIR="$CLAUDE_DIR/projects"
CONFIG_DIR="$HOME/.local/etc/agentic"
CONFIG_FILE="$CONFIG_DIR/claude_usage_config"
LOG_FILE="$CONFIG_DIR/claude_usage_monitor.log"

# Boxy orchestrator - handles graceful fallback
use_boxy() {
    if command -v boxy >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Enhanced output with boxy integration and fallback
print_header() {
    local title="$1"
    local theme="${2:-info}"
    
    if use_boxy; then
        echo "$title" | boxy --theme "$theme" --header "üõ°Ô∏è $TOOL_NAME v$TOOL_VERSION"
    else
        echo "=============================================="
        echo "üõ°Ô∏è $TOOL_NAME v$TOOL_VERSION"
        echo "$title"
        echo "=============================================="
    fi
}

print_section() {
    local content="$1"
    local theme="${2:-info}"
    local title="${3:-}"
    
    if use_boxy; then
        if [ -n "$title" ]; then
            echo -e "$content" | boxy --theme "$theme" --title "$title"
        else
            echo -e "$content" | boxy --theme "$theme"
        fi
    else
        if [ -n "$title" ]; then
            echo "--- $title ---"
        fi
        echo -e "$content"
        echo
    fi
}

print_alert() {
    local message="$1"
    local level="${2:-warning}"
    
    local theme="warning"
    local icon="‚ö†Ô∏è"
    
    case "$level" in
        "error"|"critical") theme="error"; icon="üö®" ;;
        "success") theme="success"; icon="‚úÖ" ;;
        "info") theme="info"; icon="‚ÑπÔ∏è" ;;
    esac
    
    if use_boxy; then
        echo "$message" | boxy --theme "$theme" --title "$icon Alert"
    else
        echo "$icon ALERT: $message"
    fi
}

# Logging with structured format
log_message() {
    local level="$1"
    local message="$2"
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $message" >> "$LOG_FILE"
}

# Safe JSON parsing with validation and timeout (SECURITY: Krex DEFECT_001 fix)
safe_jq() {
    local input_file="$1"
    local pattern="$2"
    if [ -f "$input_file" ] && [ -r "$input_file" ]; then
        timeout 5s jq -r "$pattern" "$input_file" 2>/dev/null || echo 0
    else
        echo 0
    fi
}

# Validate numeric input for arithmetic operations (SECURITY: Krex DEFECT_003 fix)
validate_number() {
    local input="$1"
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "$input"
    else
        echo 0
    fi
}

# Initialize configuration and directories
init_monitor() {
    print_header "Initializing Claude Usage Monitor" "info"
    
    # Create directories
    mkdir -p "$CONFIG_DIR"
    
    # Default configuration
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" << 'EOF'
# Claude Usage Monitor Configuration
# Generated by MISSION_01_CLAUDE_USAGE_DETECTION

# Alert thresholds
HIGH_USAGE_THRESHOLD=10000    # Daily token threshold for alerts
SESSION_DURATION_ALERT=480    # Alert if session > 8 hours (minutes)
CONCURRENT_SESSION_ALERT=3    # Alert if more than N concurrent sessions

# Display preferences  
DEFAULT_THEME="info"
SHOW_SENSITIVE_DATA=false     # Redact conversation content in outputs
MAX_RECENT_SESSIONS=10        # Number of sessions to show in recent view

# Security operation markers
SECURITY_PROJECT_PATTERNS="security,superhard,fortress,investigation"
TOOL_USAGE_TRACKING=true     # Track security tool usage patterns

# Reporting
DAILY_SUMMARY=true
WEEKLY_ANALYSIS=true
EOF
        print_section "‚úÖ Configuration initialized at $CONFIG_FILE" "success"
    fi
    
    # Create initial log entry
    log_message "INFO" "Claude Usage Monitor initialized - Mission: $TOOL_MISSION"
    print_section "‚úÖ Monitor ready for operational use" "success" "üéØ Deployment Status"
}

# Load configuration
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
}

# Session discovery and analysis (SECURITY: Krex DEFECT_002 fix - path traversal prevention)
find_active_sessions() {
    local time_window="${1:-1 hour ago}"
    
    # Handle different time formats for reliable date parsing - use more robust approach
    case "$time_window" in
        "today")
            # Use extended time window for today (last 1440 minutes = 24 hours) 
            # This is more reliable than -mtime 0 which can miss files due to timezone issues
            find "$PROJECTS_DIR" -name "*.jsonl" -type f -mmin -1440 2>/dev/null || true
            ;;
        "1 hour ago"|*"hour"*)
            # Use -mmin -120 for last hour (extended to 2 hours for reliability)
            find "$PROJECTS_DIR" -name "*.jsonl" -type f -mmin -120 2>/dev/null || true
            ;;
        *)
            # For backwards compatibility, try to extract time and convert to minutes if possible
            if [[ "$time_window" =~ ([0-9]+).*hour ]]; then
                local hours="${BASH_REMATCH[1]}"
                local minutes=$((hours * 60))
                # Add buffer for reliability
                local extended_minutes=$((minutes + 60))
                find "$PROJECTS_DIR" -name "*.jsonl" -type f -mmin -"$extended_minutes" 2>/dev/null || true
            else
                # Fallback to last 24 hours for unknown formats
                find "$PROJECTS_DIR" -name "*.jsonl" -type f -mmin -1440 2>/dev/null || true
            fi
            ;;
    esac
}

analyze_session_status() {
    print_header "Current Session Status" "info"
    
    # Current active sessions (last hour) - SECURITY: Safe counting
    local active_sessions
    active_sessions=$(find_active_sessions "1 hour ago")
    local active_count=$(echo "$active_sessions" | grep -c . 2>/dev/null || echo 0)
    active_count=$(validate_number "$active_count")
    
    # Today's sessions - SECURITY: Safe counting
    local today_sessions
    today_sessions=$(find_active_sessions "today")
    local today_count=$(echo "$today_sessions" | grep -c . 2>/dev/null || echo 0)
    today_count=$(validate_number "$today_count")
    
    # Build status report
    local status_report=""
    status_report+="Active Sessions (last hour): $active_count\n"
    status_report+="Today's Sessions: $today_count\n"
    
    if [ "$active_count" -gt 0 ]; then
        status_report+="\nüîÑ Currently Active Sessions:\n"
        
        while IFS= read -r session; do
            if [ -n "$session" ]; then
                local project_dir=$(dirname "$session")
                local project_name=$(basename "$project_dir" | sed 's/-home-xnull-repos-/-/' | sed 's/-/\//g')
                local session_id=$(basename "$session" .jsonl)
                local last_modified=$(stat -c %Y "$session" 2>/dev/null || echo 0)
                local current_time=$(date +%s)
                local duration=$((current_time - last_modified))
                local duration_min=$((duration / 60))
                
                # Alert on long sessions
                if [ "$duration_min" -gt "${SESSION_DURATION_ALERT:-480}" ]; then
                    status_report+="üö® $project_name - ${session_id:0:8} (${duration_min}m - LONG SESSION)\n"
                else
                    status_report+="‚Ä¢ $project_name - ${session_id:0:8} (${duration_min}m ago)\n"
                fi
            fi
        done <<< "$active_sessions"
    fi
    
    print_section "$status_report" "info"
    
    # Concurrent session alert
    if [ "$active_count" -gt "${CONCURRENT_SESSION_ALERT:-3}" ]; then
        print_alert "High concurrent session count: $active_count sessions active" "warning"
    fi
}

# Usage pattern analysis  
analyze_usage_patterns() {
    print_header "Usage Pattern Analysis" "info"
    
    # Today's usage analysis
    local today_sessions
    today_sessions=$(find_active_sessions "today")
    
    if [ -z "$today_sessions" ]; then
        print_section "No sessions found for today" "warning"
        return 0
    fi
    
    local total_messages=0
    local total_input_tokens=0
    local total_output_tokens=0
    local model_usage=""
    local tool_usage=""
    
    # Analyze each session
    while IFS= read -r session; do
        if [ -n "$session" ] && [ -f "$session" ]; then
            # Count messages
            local session_messages=$(wc -l < "$session" 2>/dev/null || echo 0)
            total_messages=$((total_messages + session_messages))
            
            # Token analysis (SECURITY: Using safe_jq parsing with validation)
            local input_tokens=0
            local output_tokens=0
            
            # Safe token calculation with timeout and validation
            while read line; do
                if [[ "$line" =~ input_tokens ]]; then
                    local token_val=$(echo "$line" | timeout 3s jq -r '.message.usage.input_tokens // 0' 2>/dev/null || echo 0)
                    token_val=$(validate_number "$token_val")
                    input_tokens=$((input_tokens + token_val))
                fi
                if [[ "$line" =~ output_tokens ]]; then
                    local token_val=$(echo "$line" | timeout 3s jq -r '.message.usage.output_tokens // 0' 2>/dev/null || echo 0)
                    token_val=$(validate_number "$token_val")
                    output_tokens=$((output_tokens + token_val))
                fi
            done < "$session" 2>/dev/null
                
            total_input_tokens=$((total_input_tokens + input_tokens))
            total_output_tokens=$((total_output_tokens + output_tokens))
            
            # Model usage patterns (SECURITY: Safe parsing with timeout)
            local session_models=""
            while read line; do
                if [[ "$line" =~ \"model\" ]]; then
                    local model=$(echo "$line" | timeout 3s jq -r '.message.model // "unknown"' 2>/dev/null || echo "unknown")
                    session_models+="$model\n"
                fi
            done < "$session" 2>/dev/null
            session_models=$(echo -e "$session_models" | sort | uniq -c | head -3 || true)
            model_usage+="$session_models\n"
            
            # Tool usage analysis (SECURITY: Safe parsing with timeout)
            local session_tools=""
            while read line; do
                if [[ "$line" =~ \"name\".*\"(Read|Write|Edit|Bash|Grep|Glob|Task)\" ]]; then
                    local tool=$(echo "$line" | timeout 3s jq -r '.message.content[]?.name // empty' 2>/dev/null | grep -v '^$' || echo "")
                    if [[ -n "$tool" ]]; then
                        session_tools+="$tool\n"
                    fi
                fi
            done < "$session" 2>/dev/null
            session_tools=$(echo -e "$session_tools" | sort | uniq -c | head -5 || true)
            tool_usage+="$session_tools\n"
        fi
    done <<< "$today_sessions"
    
    # Build analysis report
    local analysis_report=""
    analysis_report+="üìä Today's Usage Summary:\n"
    analysis_report+="‚Ä¢ Total Messages: $total_messages\n"
    analysis_report+="‚Ä¢ Input Tokens: $total_input_tokens\n"
    analysis_report+="‚Ä¢ Output Tokens: $total_output_tokens\n"
    analysis_report+="‚Ä¢ Total Tokens: $((total_input_tokens + total_output_tokens))\n\n"
    
    if [ "$total_input_tokens" -gt "${HIGH_USAGE_THRESHOLD:-10000}" ]; then
        analysis_report+="üö® High usage detected - consider quota monitoring\n\n"
    fi
    
    analysis_report+="ü§ñ Model Usage Patterns:\n"
    analysis_report+="$(echo -e "$model_usage" | sort | uniq -c | sort -nr | head -3)\n\n"
    
    analysis_report+="üõ†Ô∏è Tool Usage Patterns:\n"
    analysis_report+="$(echo -e "$tool_usage" | sort | uniq -c | sort -nr | head -5)\n"
    
    print_section "$analysis_report" "info"
    
    # High usage alert
    if [ "$total_input_tokens" -gt "${HIGH_USAGE_THRESHOLD:-10000}" ]; then
        print_alert "High token usage today: $total_input_tokens input tokens" "warning"
    fi
}

# Security-specific analysis
analyze_security_patterns() {
    print_header "Security Operations Analysis" "info"
    
    local security_patterns="${SECURITY_PROJECT_PATTERNS:-security,superhard,fortress,investigation}"
    local security_sessions=""
    
    # Find security-related sessions
    for pattern in ${security_patterns//,/ }; do
        # SECURITY: Path traversal prevention for security pattern search
        local pattern_sessions=$(find "$PROJECTS_DIR" -name "*.jsonl" -type f -not -path "*/.*" -newermt "today" -path "*$pattern*" 2>/dev/null || true)
        security_sessions+="$pattern_sessions\n"
    done
    
    security_sessions=$(echo -e "$security_sessions" | grep -v '^$' | sort | uniq || true)
    local security_count=$(echo "$security_sessions" | grep -c . 2>/dev/null || echo 0)
    
    if [ "$security_count" -eq 0 ]; then
        print_section "No security-related sessions detected today" "info"
        return 0
    fi
    
    local security_report=""
    security_report+="üõ°Ô∏è Security Operations Today: $security_count sessions\n\n"
    
    # Analyze security tool usage
    local security_tools=""
    while IFS= read -r session; do
        if [ -n "$session" ] && [ -f "$session" ]; then
            # SECURITY: Safe tool usage analysis with timeout and validation
            local session_tools=""
            while read line; do
                if [[ "$line" =~ \"name\".*\"(Bash|Task|Read|Grep|Glob)\" ]]; then
                    local tool=$(echo "$line" | timeout 3s jq -r '.message.content[]?.name // empty' 2>/dev/null | grep -v '^$' || echo "")
                    if [[ -n "$tool" ]]; then
                        session_tools+="$tool\n"
                    fi
                fi
            done < "$session" 2>/dev/null
            local tools=$(echo -e "$session_tools" | sort | uniq -c || true)
            security_tools+="$tools\n"
        fi
    done <<< "$security_sessions"
    
    security_report+="üîß Security Tool Usage:\n"
    security_report+="$(echo -e "$security_tools" | sort | uniq -c | sort -nr | head -5)\n"
    
    print_section "$security_report" "success" "üéØ Security Intelligence"
}

# Usage dashboard
show_dashboard() {
    load_config
    analyze_session_status
    echo
    analyze_usage_patterns  
    echo
    analyze_security_patterns
    echo
    
    # System status
    local system_status=""
    system_status+="üìà Monitoring Status:\n"
    system_status+="‚Ä¢ Configuration: $CONFIG_FILE\n"
    system_status+="‚Ä¢ Log File: $LOG_FILE\n"
    system_status+="‚Ä¢ Data Source: $PROJECTS_DIR\n"
    system_status+="‚Ä¢ Total Projects: $(find "$PROJECTS_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)\n"
    system_status+="‚Ä¢ Session Files: $(find "$PROJECTS_DIR" -name "*.jsonl" 2>/dev/null | wc -l)\n"
    
    print_section "$system_status" "info" "‚öôÔ∏è System Status"
}

# API validation stubs (Phase 2 preparation)
validate_usage_quota() {
    print_header "API Quota Validation (STUB)" "warning"
    print_section "üöß API integration not yet implemented\nüìã Current status: Local analysis only\nüéØ Future: Weekly quota verification with minimal API calls" "warning" "üîÆ Phase 2 Feature"
}

check_multi_client_usage() {
    print_header "Multi-Client Usage Check (STUB)" "warning"  
    print_section "üöß Cross-client analysis not yet implemented\nüìã Current scope: CLI sessions only\nüéØ Future: Web/mobile usage correlation" "warning" "üîÆ Phase 2 Feature"
}

# Command help
show_help() {
    print_header "Claude Usage Monitor - Command Reference" "info"
    
    local help_text=""
    help_text+="üéØ OPERATIONAL COMMANDS:\n"
    help_text+="  status           Current session status and activity\n"
    help_text+="  dashboard        Complete usage metrics dashboard\n"
    help_text+="  patterns         Usage pattern analysis\n"
    help_text+="  security         Security operations analysis\n\n"
    
    help_text+="üìä ANALYSIS & REPORTING:\n"
    help_text+="  daily            Daily usage summary\n" 
    help_text+="  weekly           Weekly analysis (future)\n"
    help_text+="  project [name]   Project-specific usage (future)\n\n"
    
    help_text+="üîî MONITORING & ALERTS:\n"
    help_text+="  alerts           Current alerts and warnings\n"
    help_text+="  watch            Live monitoring mode (future)\n"
    help_text+="  pressure         Context pressure analysis\n\n"
    
    help_text+="‚öôÔ∏è CONFIGURATION:\n"
    help_text+="  config           Show current configuration\n"
    help_text+="  init             Initialize monitor setup\n"
    help_text+="  validate         Check data integrity\n\n"
    
    help_text+="üîÆ API FEATURES (Phase 2 Stubs):\n"
    help_text+="  quota            Validate API quota (stub)\n"
    help_text+="  multi-client     Check multi-client usage (stub)\n\n"
    
    help_text+="üìã Mission: $TOOL_MISSION\n"
    help_text+="üõ°Ô∏è Commander: Edgar (EDGAROS)\n"
    help_text+="üéØ Objective: Zero-API Claude usage intelligence\n"
    
    print_section "$help_text" "info"
}

# Main command dispatcher
main() {
    # Ensure directories exist
    mkdir -p "$CONFIG_DIR"
    
    # Check if Claude directory exists
    if [ ! -d "$PROJECTS_DIR" ]; then
        print_alert "Claude projects directory not found: $PROJECTS_DIR" "error"
        print_section "Please ensure Claude CLI is installed and has been used at least once." "error"
        exit 1
    fi
    
    # Command dispatch
    case "${1:-dashboard}" in
        "status")
            load_config
            analyze_session_status
            ;;
        "dashboard")
            show_dashboard
            ;;
        "patterns")
            load_config
            analyze_usage_patterns
            ;;
        "security")
            load_config
            analyze_security_patterns
            ;;
        "daily")
            load_config
            show_dashboard  # Daily summary is included in dashboard
            ;;
        "alerts")
            print_header "Current Alerts" "warning"
            print_section "üîÑ Alert system operational\nüìä No critical alerts at this time\nüéØ Monitoring thresholds active" "info" "‚úÖ Alert Status"
            ;;
        "pressure")
            # Leverage existing context monitor
            if [ -f "/home/xnull/repos/security/superhard/lib/analyze/claude_context_monitor.sh" ]; then
                bash "/home/xnull/repos/security/superhard/lib/analyze/claude_context_monitor.sh"
            else
                print_section "Context pressure analysis requires fortress tools\nPath: /home/xnull/repos/security/superhard/lib/analyze/claude_context_monitor.sh" "warning" "üîß Tool Dependency"
            fi
            ;;
        "config")
            print_header "Configuration Status" "info"
            if [ -f "$CONFIG_FILE" ]; then
                cat "$CONFIG_FILE" | print_section "$(cat)" "info" "‚öôÔ∏è Current Configuration"
            else
                print_section "Configuration not found. Run 'init' to create default configuration." "warning"
            fi
            ;;
        "init")
            init_monitor
            ;;
        "validate")
            print_header "Data Integrity Check" "info"
            local total_sessions=$(find "$PROJECTS_DIR" -name "*.jsonl" 2>/dev/null | wc -l)
            local total_size=$(du -sh "$PROJECTS_DIR" 2>/dev/null | cut -f1)
            print_section "‚úÖ Projects directory: $PROJECTS_DIR\n‚úÖ Session files: $total_sessions\n‚úÖ Data size: $total_size\n‚úÖ Configuration: $([ -f "$CONFIG_FILE" ] && echo "Found" || echo "Missing")" "success" "üîç Validation Results"
            ;;
        "quota")
            validate_usage_quota
            ;;
        "multi-client")
            check_multi_client_usage
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            print_alert "Unknown command: $1" "error"
            show_help
            exit 1
            ;;
    esac
    
    # Log command execution
    log_message "INFO" "Command executed: ${1:-dashboard}"
}

# Execute main function
main "$@"